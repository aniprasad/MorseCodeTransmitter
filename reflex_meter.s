; ECE-222 Lab ... Winter 2013 term 
; Lab 3 sample code 
				THUMB 		; Thumb instruction set 
                AREA 		My_code, CODE, READONLY
                EXPORT 		__MAIN
				ENTRY  
__MAIN

; The following lines are similar to Lab-1 but use a defined address to make it easier.
; They just turn off all LEDs 
				LDR			R10, =LED_BASE_ADR			; R10 is a permenant pointer to the base address for the LEDs, offset of 0x20 and 0x40 for the ports
				MOV 		R3, #0xB0000000				; Turn off three LEDs on port 1  
				STR 		R3, [r10, #0x20]
				MOV 		R3, #0x0000007C
				STR 		R3, [R10, #0x40] 			; Turn off five LEDs on port 2 
				MOV			R11, #0xABCD     			; Init the random number generator with a non-zero number
				MOV 		R5, #0						; Clear R5 before use
				MOV         R9, #0						; Clear R9 before use
				MOV         R0, #0						; Clear R0 before use
				MOV         R12, #0						; Clear R12 before use
														
loop 			MOV         R3, #0                  	; Clear R3 before use
				MOV         R6, #0						; Clear R6 before use
				MOV         R0, #0						; Clear R0 before use
				MOV         R7, #78						; Move 78 into R7. This serves as an offset
				BL 			RandomNum       			; Call RandomNum Subroutine which would generate a random number 
				MOV         R0, R11						; Move that random number into R0
				MUL 		R0, R7						; Multiply the random number generated by R0
				MOV         R7, #100				
				UDIV        R0, R7						; Divide the random number now by 100 in order to make the delay between 2-10 seconds
				MOV         R7, #0						; Clear R7 to 0 as its purpose has now been completed
				MOV			R7, #0x4E20					; Move #0x4E20 into R7. This is 20000 in decimal to give us a two second delay
				ADD			R0, R7						; Add this to the random number generated so that even the smallest random number will have a 2 second delay
				BL 			DELAY						; Call the delay subroutine
				MOV         R8, #0						; Clear R8 
				MOV         R8, #0x90000000   			; Holds the address for P1.29 
				STR         R8, [R10, #0x20]			; Switches on the LED after an appropriate delay has been passed	
				MOV         R7, #0            			; Clear Counter variable for calculating the time
				

POLLING         LDR         R6, =FIO2PIN				; Load the P2 address [31:0] into R6
				LDR         R6, [R6]					; Load the contents pointed to the by the memory address into R6
				LSR         R6, #10						; Do a logical shift right of 10 bits because we have to extract the 10th bit
				BFI         R9, R6, #0, #1				; Now the 10th bit is a position 0. BFI extracts the first bit and stores it in R9
				
				MOV         R0, #0						; Clear delay register
				MOV         R0, #1 						; Have a 10th of a second delay
				BL 			DELAY						; Call Delay Subroutine
				
				ADD         R7, R7, #1       			; Increment the counter by 1 to start counting the time
				
				TEQ         R9, #0           			; Check if the 10th bit is zero. 
				BNE         POLLING						; If it is not zero then the button has not been pressed and we have to go back to the polling subroutine
				
				MOV         R8, #0xB0000000				; If it is zero, then the button has been pressed and we have to turn off the LED
				STR         R8, [R10, #0x20]			; Switch off the light by adding the appropriate offset into the base LED address
				
				; Putting counter into another register for later use
				; because R7 gets changed in SHOW_32_BIT_TIME
				MOV R12, R7
				
RESET_VALUES    		MOV R7, R12						; Restore the temporary value as you want to keep looping 
						MOV R8, #4						; Move 4 into R8, as there are 4 sets of data (each of 8 bits)to show
				

SHOW_32_BIT_TIME       MOV  R3, #0						; Clear R3 before use
					   BFI  R3, R7, #0, #8				; Extract the first set of 8 bits
					   LSR  R7, #8						; Shift R7 right by 8 bits to get the next set of 8 bits ready
					   BL DISPLAY_NUM					; Go the display_num subroutine to display individual sets of bits
					   
					   MOV  R0, #0						; Clear delay register
					   MOV  R0, #0x4E20 				; Move #0x4E20 into R7. This is 20000 in decimal to give us a 20000*0.1ms = 2s delay
					   BL DELAY							; Call the DELAY subroutine
					   
					   SUBS R8, #1						; Decrement the counter by 1 and set the flag
					   BNE  SHOW_32_BIT_TIME  			; If the counter is not zero,we still have to display the data. Hence go back to the subroutine
					   
					   MOV  R0, #0						; Clear delay register
					   MOV  R0, #0x7F8A 				; Move #0x7F8A into R0. This is 50000 in decimal to give us a 50000*0.1ms = 5s delay
					   BL DELAY							; Call the DELAY subroutine
					   
					   B RESET_VALUES					; Call the RESET_VALUES subroutine in order to start displaying the time again from the beginning
					   B loop

;
; Display the number in R3 onto the 8 LEDs
DISPLAY_NUM		STMFD		R13!,{R1, R2, R3, R7, R6, R14}
				
				MOV 		R5, #0						; Clear R5 before use
				MOV			R6, #0						; Clear R6 before use
				BFI         R6, R3, #0, #5				; Extract the first 5 bits corresponding from R3 to port 2 and store in R6
				RBIT        R6, R6						; Reverse the bits so that they match port 2
				LSR         R6, #25						; Do a logical shift right of 25 bits to make room for the 0th and the 1st bit
			         
				EOR         R6, #0xFFFFFFFF				; Invert the bits since it is active low. ie: 0 is on and 1 is off
				STR         R6, [R10, #0x40]			; Switch on the lights by adding the appropriate offset to the base LED address
				
				
				MOV 		R6, #0						; Clear R6 before use again
				LSR			R3, #5						; Do a logical shift right of 5 bits so that we have the first three bits of Port 1
				BFI         R6, R3, #0, #1 				; Extract bit 31 from R3
				
				LSL         R3, #1						; Do a logical shift left of 1 bit to make room for the 30th bit
				ADD         R6, R3						; Add R3 to R6 so R6 now holds the Port 1 address
				RBIT        R6, R6						; Reverse the bits so that they match port 1
				
				EOR         R6, #0xFFFFFFFF				; Invert the bits since it is active love. ie: 0 is on and 1 is off
				STR         R6, [R10, #0x20]			; Switch on the lights by adding the appropriate offset to the base LED address
				

				LDMFD		R13!,{R1, R2, R3, R7, R6, R15}
				
				
;
; R11 holds a 16-bit random number via a pseudo-random sequence as per the Linear feedback shift register (Fibonacci) on WikiPedia
; R11 holds a non-zero 16-bit number.  If a zero is fed in the pseudo-random sequence will stay stuck at 0
; Take as many bits of R11 as you need.  If you take the lowest 4 bits then you get a number between 1 and 15.
;   If you take bits 5..1 you'll get a number between 0 and 15 (assuming you right shift by 1 bit).
;
; R11 MUST be initialized to a non-zero 16-bit value at the start of the program OR ELSE!
; R11 can be read anywhere in the code but must only be written to by this subroutine
RandomNum		STMFD		R13!,{R1, R2, R3, R14}

				AND			R1, R11, #0x8000
				AND			R2, R11, #0x2000
				LSL			R2, #2
				EOR			R3, R1, R2
				AND			R1, R11, #0x1000
				LSL			R1, #3
				EOR			R3, R3, R1
				AND			R1, R11, #0x0400
				LSL			R1, #5
				EOR			R3, R3, R1					; The new bit to go into the LSB is present
				LSR			R3, #15
				LSL			R11, #1
				ORR			R11, R11, R3
				
				LDMFD		R13!,{R1, R2, R3, R15}

DELAY			STMFD		R13!,{R2, R14}
				MOV         R2, #0						; Clear R2 before use
				MOV        	R2, #0x0042  			    ; Add the 0.1ms delay to R2
				MUL         R0, R2						; R0 * R1 will give us the required delay
MultipleDelay   TEQ         R0, #0						; Test if R0 is zero
                SUB         R0, #1						; Subtract 1 from R0 
				BEQ         exitDelay					; If R0 is zero then delay is done and we return back to the calling routine
				BNE         MultipleDelay				; If R0 is not zero then delay has not yet completed, and hence we keep looping

exitDelay		LDMFD		R13!,{R2, R15}




LED_BASE_ADR	EQU 	0x2009c000 		; Base address of the memory that controls the LEDs 
TEST_LABEL		EQU     0x186A0			; change to 186A0
FIO2PIN         EQU     0x2009c054		; FIO2PIN is used to read P2[31:0]
PINSEL3			EQU 	0x4002c00c 		; Address of Pin Select Register 3 for P1[31:16]
PINSEL4			EQU 	0x4002c010 		; Address of Pin Select Register 4 for P2[15:0]


; POSTLAB QUESTIONS
; Question 1
; a) 8 bits -> 0.0255s
; b) 16 bits -> 6.5535s
; c) 24 bits -> 1677.7s
; d) 32 bits -> 429496.7295
; Question 2
; Considering Normal human reaction time which is in the range of 0.1s to 0.5s, 16 bits would be best suited for this task



				ALIGN 

				END 